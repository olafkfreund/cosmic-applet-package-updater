# Implementation Plan: Add NixOS Support to Package Updater Applet

## Overview
Add NixOS package update detection to the COSMIC applet, supporting both traditional channels and modern flakes approaches.

## Research Summary

### Key Findings
1. **NixOS is declarative** - Updates are "system generation changes" not individual package updates
2. **Two update mechanisms:**
   - **Channels**: Traditional, uses `nix-channel --update` + `nixos-rebuild`
   - **Flakes**: Modern, uses `flake.nix` + `flake.lock` files
3. **Detection approach:**
   - Channels: Run `nixos-rebuild dry-activate --upgrade` (requires sudo)
   - Flakes: Check `flake.lock` changes via `nix flake update --dry-run`
4. **Config locations:**
   - System: `/etc/nixos/` (typical)
   - Flake: `/etc/nixos/flake.nix` and `/etc/nixos/flake.lock`
   - User: Can be in custom locations (needs configuration)

## Implementation Phases

### Phase 1: Core Data Structures (Foundation)

#### 1.1 Add NixOS Package Manager Variant
**File:** `package-updater/src/package_manager.rs`

**Changes:**
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PackageManager {
    // ... existing variants ...
    NixOS,
}

impl PackageManager {
    pub fn name(&self) -> &'static str {
        match self {
            // ... existing cases ...
            PackageManager::NixOS => "nixos",
        }
    }

    pub fn system_update_command(&self) -> String {
        match self {
            // ... existing cases ...
            PackageManager::NixOS => {
                // Will be dynamic based on config mode
                "sudo nixos-rebuild switch".to_string()
            }
        }
    }
}
```

#### 1.2 Add NixOS-Specific Configuration
**File:** `package-updater/src/config.rs`

**Changes:**
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum NixOSMode {
    Channels,
    Flakes,
}

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NixOSConfig {
    pub mode: NixOSMode,
    pub config_path: String,  // Default: "/etc/nixos"
}

impl Default for NixOSConfig {
    fn default() -> Self {
        Self {
            mode: NixOSMode::Flakes,  // Modern default
            config_path: "/etc/nixos".to_string(),
        }
    }
}

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct PackageUpdaterConfig {
    // ... existing fields ...
    pub nixos_config: NixOSConfig,
}
```

**Reasoning:** Separate NixOS config structure keeps related settings together and makes it easy to extend.

---

### Phase 2: Detection Logic

#### 2.1 Implement NixOS System Detection
**File:** `package-updater/src/package_manager.rs`

**New function:**
```rust
impl PackageManagerDetector {
    fn is_nixos_available() -> bool {
        // Check if nixos-rebuild exists
        let nixos_rebuild = Command::new("which")
            .arg("nixos-rebuild")
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false);

        if !nixos_rebuild {
            return false;
        }

        // Check if we're actually on NixOS
        std::path::Path::new("/etc/NIXOS").exists() ||
        std::path::Path::new("/run/current-system").exists()
    }

    fn detect_nixos_mode(config_path: &str) -> NixOSMode {
        let flake_path = std::path::Path::new(config_path).join("flake.nix");
        if flake_path.exists() {
            NixOSMode::Flakes
        } else {
            NixOSMode::Channels
        }
    }
}
```

**Integration:**
Update `detect_available()` to include NixOS detection.

#### 2.2 Implement Channels Update Checker
**File:** `package-updater/src/package_manager.rs`

**New function:**
```rust
impl UpdateChecker {
    async fn check_nixos_channels(&self) -> Result<Vec<PackageUpdate>> {
        // Run nixos-rebuild dry-activate with upgrade flag
        let output = TokioCommand::new("sudo")
            .args(&["nixos-rebuild", "dry-activate", "--upgrade"])
            .output()
            .await?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed to check NixOS updates: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse output to detect changes
        // Look for patterns like:
        // - "would start the following units:"
        // - "would restart the following units:"
        // - "would reload the following units:"

        self.parse_nixos_rebuild_output(&stdout)
    }

    fn parse_nixos_rebuild_output(&self, output: &str) -> Result<Vec<PackageUpdate>> {
        let mut updates = Vec::new();
        let mut in_changes_section = false;

        for line in output.lines() {
            // Detect section headers
            if line.contains("would start") ||
               line.contains("would restart") ||
               line.contains("would reload") ||
               line.contains("would stop") {
                in_changes_section = true;
                continue;
            }

            // Empty line ends section
            if line.trim().is_empty() {
                in_changes_section = false;
                continue;
            }

            // Parse unit/service name from indented lines
            if in_changes_section && line.starts_with("  ") {
                let service_name = line.trim();
                updates.push(PackageUpdate {
                    name: service_name.to_string(),
                    current_version: "current".to_string(),
                    new_version: "updated".to_string(),
                    is_aur: false,
                });
            }
        }

        // If no specific changes found but command succeeded,
        // there might be a generation available
        if updates.is_empty() && output.contains("building") {
            updates.push(PackageUpdate {
                name: "NixOS System".to_string(),
                current_version: "current generation".to_string(),
                new_version: "new generation available".to_string(),
                is_aur: false,
            });
        }

        Ok(updates)
    }
}
```

#### 2.3 Implement Flakes Update Checker
**File:** `package-updater/src/package_manager.rs`

**New function:**
```rust
impl UpdateChecker {
    async fn check_nixos_flakes(&self, config_path: &str) -> Result<Vec<PackageUpdate>> {
        let flake_lock_path = std::path::Path::new(config_path).join("flake.lock");

        // Read current flake.lock
        let current_lock = tokio::fs::read_to_string(&flake_lock_path).await?;
        let current_json: serde_json::Value = serde_json::from_str(&current_lock)?;

        // Run nix flake update --dry-run to see what would change
        let output = TokioCommand::new("nix")
            .args(&["flake", "update", "--dry-run"])
            .current_dir(config_path)
            .output()
            .await?;

        // Parse the dry-run output
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        // Nix flake output goes to stderr for some operations
        let combined_output = format!("{}\n{}", stdout, stderr);

        // Look for patterns like:
        // • Updated 'nixpkgs': 'github:NixOS/nixpkgs/abc123' -> 'github:NixOS/nixpkgs/def456'
        self.parse_flake_update_output(&combined_output, &current_json)
    }

    fn parse_flake_update_output(
        &self,
        output: &str,
        _current_lock: &serde_json::Value
    ) -> Result<Vec<PackageUpdate>> {
        let mut updates = Vec::new();

        // Regex to match: • Updated 'input': 'old' -> 'new'
        let update_regex = regex::Regex::new(
            r"(?:Updated|Will update)\s+'([^']+)':\s+'([^']+)'\s+->\s+'([^']+)'"
        )?;

        for line in output.lines() {
            if let Some(captures) = update_regex.captures(line) {
                let input_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown");
                let old_rev = captures.get(2).map(|m| m.as_str()).unwrap_or("unknown");
                let new_rev = captures.get(3).map(|m| m.as_str()).unwrap_or("unknown");

                // Extract short commit hashes if present
                let old_short = old_rev.split('/').last().unwrap_or(old_rev);
                let new_short = new_rev.split('/').last().unwrap_or(new_rev);

                updates.push(PackageUpdate {
                    name: format!("flake input: {}", input_name),
                    current_version: old_short.to_string(),
                    new_version: new_short.to_string(),
                    is_aur: false,
                });
            }
        }

        // If no updates detected but command succeeded, check if output mentions "up to date"
        if updates.is_empty() && !output.contains("up to date") && !output.is_empty() {
            // Might be updates but couldn't parse them
            updates.push(PackageUpdate {
                name: "NixOS Flake".to_string(),
                current_version: "check manually".to_string(),
                new_version: "updates may be available".to_string(),
                is_aur: false,
            });
        }

        Ok(updates)
    }

    async fn check_nixos_updates(&self, config: &NixOSConfig) -> Result<Vec<PackageUpdate>> {
        match config.mode {
            NixOSMode::Channels => self.check_nixos_channels().await,
            NixOSMode::Flakes => self.check_nixos_flakes(&config.config_path).await,
        }
    }
}
```

**Dependencies to add:**
- `serde_json` - For parsing flake.lock JSON
- `regex` - For parsing flake update output (already in Cargo.toml)

#### 2.4 Integrate NixOS into Main Update Check
**File:** `package-updater/src/package_manager.rs`

**Modify `check_official_updates()`:**
```rust
async fn check_official_updates(&self, nixos_config: &NixOSConfig) -> Result<Vec<PackageUpdate>> {
    let (cmd, args) = match self.package_manager {
        // ... existing cases ...
        PackageManager::NixOS => {
            return self.check_nixos_updates(nixos_config).await;
        }
    };

    self.parse_update_output(cmd, args, false).await
}
```

---

### Phase 3: UI Integration

#### 3.1 Add NixOS Settings Section
**File:** `package-updater/src/app.rs`

**Modify `view_settings_tab()`:**
```rust
fn view_settings_tab(&self) -> Element<'_, Message> {
    let mut widgets = vec![];

    // ... existing package manager selection ...

    // NixOS-specific settings (only show if NixOS is selected)
    if self.config.package_manager == Some(PackageManager::NixOS) {
        widgets.push(Space::with_height(cosmic::iced::Length::Fixed(16.0)).into());
        widgets.push(text("NixOS Configuration").size(16).into());

        // Mode selection: Flakes vs Channels
        let flakes_selected = matches!(self.config.nixos_config.mode, NixOSMode::Flakes);
        widgets.push(
            row()
                .spacing(8)
                .push(
                    button::text(if flakes_selected { "● Flakes" } else { "○ Flakes" })
                        .on_press(Message::SetNixOSMode(NixOSMode::Flakes))
                        .width(cosmic::iced::Length::Fill)
                )
                .push(
                    button::text(if !flakes_selected { "● Channels" } else { "○ Channels" })
                        .on_press(Message::SetNixOSMode(NixOSMode::Channels))
                        .width(cosmic::iced::Length::Fill)
                )
                .into()
        );

        widgets.push(Space::with_height(cosmic::iced::Length::Fixed(8.0)).into());

        // Config path input
        widgets.push(text("Configuration Path").size(14).into());
        widgets.push(
            text_input("/etc/nixos", &self.config.nixos_config.config_path)
                .on_input(Message::SetNixOSConfigPath)
                .width(cosmic::iced::Length::Fill)
                .into()
        );

        // Help text
        widgets.push(
            text("Path to your NixOS configuration directory")
                .size(10)
                .into()
        );

        // Auto-detection button
        widgets.push(Space::with_height(cosmic::iced::Length::Fixed(8.0)).into());
        widgets.push(
            button::text("Auto-detect Mode")
                .on_press(Message::AutoDetectNixOSMode)
                .width(cosmic::iced::Length::Fill)
                .into()
        );
    }

    // ... rest of existing settings ...
}
```

#### 3.2 Add New Messages
**File:** `package-updater/src/app.rs`

```rust
#[derive(Debug, Clone)]
pub enum Message {
    // ... existing variants ...
    SetNixOSMode(NixOSMode),
    SetNixOSConfigPath(String),
    AutoDetectNixOSMode,
}
```

#### 3.3 Implement Message Handlers
**File:** `package-updater/src/app.rs`

```rust
fn update(&mut self, message: Self::Message) -> Task<Self::Message> {
    match message {
        // ... existing cases ...

        Message::SetNixOSMode(mode) => {
            let mut config = self.config.clone();
            config.nixos_config.mode = mode;
            Task::done(cosmic::Action::App(Message::ConfigChanged(config)))
        }

        Message::SetNixOSConfigPath(path) => {
            let mut config = self.config.clone();
            config.nixos_config.config_path = path;
            Task::done(cosmic::Action::App(Message::ConfigChanged(config)))
        }

        Message::AutoDetectNixOSMode => {
            let config_path = self.config.nixos_config.config_path.clone();
            let detected_mode = PackageManagerDetector::detect_nixos_mode(&config_path);

            let mut config = self.config.clone();
            config.nixos_config.mode = detected_mode;
            Task::done(cosmic::Action::App(Message::ConfigChanged(config)))
        }
    }
}
```

#### 3.4 Update System Update Command for NixOS
**File:** `package-updater/src/package_manager.rs`

```rust
impl PackageManager {
    pub fn system_update_command_with_config(&self, nixos_config: &NixOSConfig) -> String {
        match self {
            // ... existing cases ...
            PackageManager::NixOS => {
                match nixos_config.mode {
                    NixOSMode::Channels => {
                        "sudo nix-channel --update && sudo nixos-rebuild switch --upgrade".to_string()
                    }
                    NixOSMode::Flakes => {
                        format!(
                            "cd {} && nix flake update && sudo nixos-rebuild switch --flake .#",
                            nixos_config.config_path
                        )
                    }
                }
            }
        }
    }
}
```

---

### Phase 4: Permission Handling

#### 4.1 Handle Sudo Requirements
**Note:** NixOS update checks require elevated permissions.

**Options:**
1. **Prompt user to configure passwordless sudo** (recommended approach)
2. **Show instructions in error message** when permission denied
3. **Alternative: Use polkit for privilege escalation** (complex)

**Implementation:**
```rust
impl UpdateChecker {
    async fn check_nixos_channels(&self) -> Result<Vec<PackageUpdate>> {
        let output = TokioCommand::new("sudo")
            .args(&["nixos-rebuild", "dry-activate", "--upgrade"])
            .output()
            .await?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);

            // Check if it's a permission issue
            if stderr.contains("not allowed") || stderr.contains("password") {
                return Err(anyhow!(
                    "Permission denied. Configure passwordless sudo for nixos-rebuild:\n\
                     Add to /etc/sudoers.d/nixos-rebuild:\n\
                     %wheel ALL=(ALL) NOPASSWD: /run/current-system/sw/bin/nixos-rebuild"
                ));
            }

            return Err(anyhow!("Failed to check NixOS updates: {}", stderr));
        }

        // ... rest of function ...
    }
}
```

---

### Phase 5: Testing & Polish

#### 5.1 Testing Checklist
- [ ] Test NixOS detection on NixOS system
- [ ] Test channels mode on system using channels
- [ ] Test flakes mode on system using flakes
- [ ] Test auto-detection of mode
- [ ] Test custom config path
- [ ] Test permission denied handling
- [ ] Test update count display
- [ ] Test terminal update command execution
- [ ] Test multi-instance synchronization with NixOS
- [ ] Test error messages are user-friendly

#### 5.2 Edge Cases to Handle
1. **Flake.lock doesn't exist** - Show error, suggest running `nix flake update` manually
2. **Config path doesn't exist** - Validate on input, show error
3. **User doesn't have sudo** - Clear error message with instructions
4. **Nix commands not in PATH** - Detection should fail gracefully
5. **Network issues** - Retry logic (already implemented)

#### 5.3 Documentation Updates
**File:** `README.md`

Add section:
```markdown
### NixOS Support

The Package Updater now supports NixOS with both channels and flakes!

**Supported Modes:**
- **Channels**: Traditional NixOS update mechanism
- **Flakes**: Modern reproducible configuration approach

**Configuration:**
1. Select "nixos" from Package Managers in Settings
2. Choose your mode: Flakes or Channels
3. Set your NixOS configuration path (default: `/etc/nixos`)
4. Click "Auto-detect Mode" to automatically detect your setup

**Requirements:**
- NixOS system with `nixos-rebuild` available
- For update checks: passwordless sudo configured (see below)
- For flakes: Valid `flake.nix` and `flake.lock` in config directory

**Passwordless Sudo Setup:**
Add to `/etc/sudoers.d/nixos-rebuild`:
```
%wheel ALL=(ALL) NOPASSWD: /run/current-system/sw/bin/nixos-rebuild
```

**How Updates Work:**
- **Channels**: Runs `nixos-rebuild dry-activate --upgrade` to check for updates
- **Flakes**: Runs `nix flake update --dry-run` to check for input updates

**Update Command:**
- **Channels**: `sudo nix-channel --update && sudo nixos-rebuild switch --upgrade`
- **Flakes**: `nix flake update && sudo nixos-rebuild switch --flake <path>#`
```

#### 5.4 CLAUDE.md Updates
**File:** `CLAUDE.md`

Add to "Package Manager Support" section:
```markdown
**NixOS:**
- Channels (traditional update mechanism)
- Flakes (modern, reproducible approach)
- Requires elevated permissions (sudo) for update checks
- Config path is user-configurable (default: `/etc/nixos`)
- Detection via presence of `flake.nix` or system indicators
```

---

## Implementation Order

1. **Phase 1** - Add data structures (foundational changes)
2. **Phase 2.1** - Implement detection logic
3. **Phase 2.2** - Implement channels checker
4. **Phase 2.3** - Implement flakes checker
5. **Phase 2.4** - Integrate into main flow
6. **Phase 3** - Add UI components
7. **Phase 4** - Handle permissions
8. **Phase 5** - Testing and documentation

## Dependencies to Add

**File:** `package-updater/Cargo.toml`

```toml
[dependencies]
serde_json = "1.0"  # For parsing flake.lock
# regex already present
```

## Estimated Complexity

- **Data Structures**: Low complexity, straightforward additions
- **Detection Logic**: Medium complexity, multiple commands to handle
- **Parsing**: Medium-high complexity, regex and JSON parsing
- **UI Changes**: Low complexity, follows existing patterns
- **Permissions**: Medium complexity, needs clear error messages
- **Testing**: High effort, requires NixOS system

## Risks & Mitigations

| Risk | Mitigation |
|------|-----------|
| Sudo password prompts block UI | Clear error message, documentation for passwordless sudo setup |
| Flake.lock parsing changes | Use stable JSON structure, fallback to manual check |
| Permission issues on locked systems | Provide clear instructions, detect and inform user |
| Different NixOS versions behave differently | Test on multiple NixOS versions, handle variations |

## Success Criteria

- ✅ NixOS appears in package manager list on NixOS systems
- ✅ Auto-detection correctly identifies flakes vs channels
- ✅ Update checking works for both modes
- ✅ UI shows appropriate settings for NixOS
- ✅ Terminal update command works correctly
- ✅ Error messages are clear and actionable
- ✅ Documentation is complete and accurate

---

## Future Enhancements (Out of Scope for Initial Implementation)

1. **Home Manager Integration** - Detect home-manager updates separately
2. **Generation History** - Show previous system generations
3. **Flake Input Details** - Show detailed changelog for each input
4. **Profile Support** - Support multiple NixOS configurations/profiles
5. **Remote Flake Updates** - Check GitHub for newer commits without updating lock
